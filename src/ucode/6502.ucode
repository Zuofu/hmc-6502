# 6502.ucode
# input for ucodeasm
# tbarr at cs hmc edu, 28oct07

reset:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	th_lat	pcinc
0x00	-	pass	p	p	-	-	-	-	0
0x00	-	pass	a	0	-	-	-	-	0
0xff	-	pass	sp	0	-	-	-	-	0
0xf0	-	pass	pc_h	10	r	-	-	1	0
0x00	-	pass	pc_l	01	r	temp	r	0	0

# ensure that base state in assembler is changed to reflect changes here.
base:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	sta_src	last_cy
db	-	pass	none	1	pc_n	pc_n	pc_n	0	0	opcode	0

branch_taken:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	pcinc	flag	tl_lat	th_lat
0x0	pc_h	add+t	pc_h	10	r	-	-	0	0	0	1
tl	-	pass	pc_l	01	r	temp	temp	0	0	0	0

none:
# just fetch next instruction
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag
-	-	pass	none	0	-	pc_n	pc_n	0	0

single_byte:
# 1.0
a_sel	b_sel	alu_op	wrt_en	pcinc	pc_sel	a_h_sel	a_l_sel	tl_lat	flag
func	func	func	func	0	-	pc_n	pc_n	0	1

# single_byte with a zero carry
single_byte_zc:
a_sel	b_sel	alu_op	wrt_en	pcinc	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	c_sel
func	func	func	func	0	-	pc_n	pc_n	0	1	0

imm:
# immediate addressing (5.4)
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag
db	func	func	func	1	pc_n	pc_n	pc_n	0	1

# imm with a zero carry
imm_zc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	c_sel
db	func	func	func	1	pc_n	pc_n	pc_n	0	1	0

# imm with a one carry
imm_oc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	c_sel
db	func	func	func	1	pc_n	pc_n	pc_n	0	1	1

mem_ex_zpa:
# 5.6
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag
db	-	pass	none	0	pc_n	0	r	0	0
db	func	func	func	1	pc_n	pc_n	pc_n	0	1

# mem_ex_zpa with a one carry
mem_ex_zpa_oc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	c_sel
db	-	pass	none	0	pc_n	0	r	0	0	-
db	func	func	func	1	pc_n	pc_n	pc_n	0	1	1

# mem_ex_zpa with a zero carry
mem_ex_zpa_zc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	c_sel
db	-	pass	none	0	pc_n	0	r	0	0	-
db	func	func	func	1	pc_n	pc_n	pc_n	0	1	0

mem_wr_zpa:
# 5.6
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	memwri
db	func	pass	none	0	pc_n	0	r	0	0	b
db	-	-	none	1	pc_n	pc_n	pc_n	0	1	0

# mem_wr_zpa with a zero carry
#mem_wr_zpa_zc:
#a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	memwri	c_sel
#db	func	pass	none	0	pc_n	0	r	0	0	b	0
#db	-	-	none	1	pc_n	pc_n	pc_n	0	1	0	-

mem_wr_zpx:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	memwri
db	x	add	none	0	pc_n	0	-	1	0	0
-	func	-	none	0	-	0	temp	0	0	b
db	-	-	none	1	pc_n	pc_n	pc_n	0	1	0

# mem_wr_zpx with a zero carry
#mem_wr_zpx_zc:
#a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	memwri	c_sel
#db	x	add	none	0	pc_n	0	-	1	0	0	-
#-	func	-	none	0	-	0	temp	0	0	b	0
#db	-	-	none	1	pc_n	pc_n	pc_n	0	1	0	-

mem_wr_zpy:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	memwri
db	y	add	none	0	pc_n	0	-	1	0	0
-	func	-	none	0	-	0	temp	0	0	b
db	-	-	none	1	pc_n	pc_n	pc_n	0	1	0

# mem_wr_zpy with a zero carry
#mem_wr_zpy_zc:
#a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	memwri	c_sel
#db	y	add	none	0	pc_n	0	-	1	0	0	-
#-	func	-	none	0	-	0	temp	0	0	b	0
#db	-	-	none	1	pc_n	pc_n	pc_n	0	1	0	-

mem_wr_abs:
# 5.6
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	memwri
db	-	pass	none	1	pc_n	pc_n	pc_n	1	0	0
db	func	pass	none	0	-	r	temp	0	0	b
db	-	-	none	1	pc_n	pc_n	pc_n	0	1	0

# mem_wr_abs with a zero carry
#mem_wr_abs_zc:
#a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	memwri	c_sel
#db	-	pass	none	1	pc_n	pc_n	pc_n	1	0	0	-
#db	func	pass	none	0	-	r	temp	0	0	b	0
#db	-	-	none	1	pc_n	pc_n	pc_n	0	1	0	-


mem_wr_abx:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	th_lat	tl_lat	flag	memwri
db	x	add	none	1	pc_n	pc_n	pc_n	0	1	t	0
db	-	pass+t	none	0	-	-	-	1	0	0	0
db	func	pass	none	0	-	temp	temp	0	0	0	b
db	-	-	none	1	pc_n	pc_n	pc_n	0	0	1	0

mem_wr_abs:
# 5.6
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	memwri
db	-	pass	none	1	pc_n	pc_n	pc_n	1	0	0
db	func	pass	none	0	-	r	temp	0	0	b
db	-	-	none	1	pc_n	pc_n	pc_n	0	1	0

# mem_wr_abs with a zero carry
#mem_wr_abs_zc:
#a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	memwri	c_sel
#db	-	pass	none	1	pc_n	pc_n	pc_n	1	0	0	-
#db	func	pass	none	0	-	r	temp	0	0	b	0
#db	-	-	none	1	pc_n	pc_n	pc_n	0	1	0	-

mem_wr_aby:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	th_lat	tl_lat	flag	memwri
db	y	add	none	1	pc_n	pc_n	pc_n	0	1	t	0
db	-	pass+t	none	0	-	-	-	1	0	0	0
db	func	pass	none	0	-	temp	temp	0	0	0	b
db	-	-	none	1	pc_n	pc_n	pc_n	0	0	1	0

mem_wr_idy:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	th_lat	tl_lat	flag	memwri
# Address of low byte comes in over data line -- save it in temp_high and pass it to address
db	-	pass	none	0	-	0	r	1	0	0	0
# Low byte comes in on data -- pass it and store in temp_low
db	-	pass	none	0	-	pc_n	pc_n	0	1	0	0
# Increment address of low byte to get address of high byte -- pass to address 
th	-	inc	none	0	-	0	r	0	0	0	0
# Data from high byte comes in -- save in temp_high
db	-	pass	none	0	-	-	-	1	0	0	0
# Add y to low byte and save back in low byte
tl	y	add	none	0	-	temp	r	0	1	t	0
# Add carry to high byte and save back in high byte
th	-	pass+t	none	0	-	r	temp	1	0	0	0
# Use temporary register as address and write whatever func says
-	func	pass	none	0	-	temp	temp	0	0	0	b
# Incremet the program counter and set the flags
db	-	-	none	1	pc_n	pc_n	pc_n	0	0	1	0

mem_wr_idx:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	th_lat	tl_lat	flag	memwri
# store instruction input in temp_low:
db	-	pass	none	0	-	-	-	0	1	0	0
# get memory location of high byte address:
tl	x	add+1	none	0	-	0	r	0	0	0	0
# store high byte address in temp_high:
db	-	pass	none	0	-	-	-	1	0	0	0
# get memory location of low byte address:
tl	x	add	none	0	-	0	r	0	0	0	0
# knowing result is low byte address, get data for writing:
db	func	pass	none	0	-	temp	r	0	0	0	b
# final write state:
db	-	-	none	1	pc_n	pc_n	pc_n	0	0	1	0

abs:
#5.5
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag
db	-	pass	none	1	pc_n	pc_n	pc_n	1	0
db	-	pass	none	0	-	r	temp	0	0
db	func	func	func	1	pc_n	pc_n	pc_n	0	1

# abs with a one carry:
abs_oc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	c_sel
db	-	pass	none	1	pc_n	pc_n	pc_n	1	0	-
db	-	pass	none	0	-	r	temp	0	0	-
db	func	func	func	1	pc_n	pc_n	pc_n	0	1	1

# abs with a zero carry:
abs_zc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	c_sel
db	-	pass	none	1	pc_n	pc_n	pc_n	1	0	-
db	-	pass	none	0	-	r	temp	0	0	-
db	func	func	func	1	pc_n	pc_n	pc_n	0	1	0

indirect_x:
# Fetch opcode, then base offset+X, stored in a_lat. Repeat for offset+x+1, 
# assert onto address bus, use as high part of next fetch
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	th_lat	tl_lat	flag
# store instruction input in temp_low:
db	-	pass	none	0	-	-	-	0	1	0
# get memory location of high byte address:
tl	x	add+1	none	0	-	0	r	0	0	0
# store high byte address in temp_high:
db	-	pass	none	0	-	-	-	1	0	0
# get memory location of low byte address:
tl	x	add	none	0	-	0	r	0	0	0
# knowing result is low byte address, get data from memory:
db	-	pass	none	0	-	temp	r	0	0	0
# finally, do the instruction function:
db	func	func	func	1	pc_n	pc_n	pc_n	0	0	1	

# indirect_x with a one carry
indirect_x_oc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	th_lat	tl_lat	flag	c_sel
db	-	pass	none	0	-	-	-	0	1	0	-
tl	x	add+1	none	0	-	0	r	0	0	0	-
db	-	pass	none	0	-	-	-	1	0	0	-
tl	x	add	none	0	-	0	r	0	0	0	-
db	-	pass	none	0	-	temp	r	0	0	0	-
db	func	func	func	1	pc_n	pc_n	pc_n	0	0	1	1

# indirect_x with a zero carry
indirect_x_zc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	th_lat	tl_lat	flag	c_sel
db	-	pass	none	0	-	-	-	0	1	0	-
tl	x	add+1	none	0	-	0	r	0	0	0	-
db	-	pass	none	0	-	-	-	1	0	0	-
tl	x	add	none	0	-	0	r	0	0	0	-
db	-	pass	none	0	-	temp	r	0	0	0	-
db	func	func	func	1	pc_n	pc_n	pc_n	0	0	1	0

abs_x:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag
db	x	add	none	1	pc_n	pc_n	pc_n	1	t
db	-	pass+t	none	0	-	r	temp	0	0
db	func	func	func	1	pc_n	pc_n	pc_n	0	1

# abs_x with a one carry
abs_x_oc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	c_sel
db	x	add	none	1	pc_n	pc_n	pc_n	1	t	-
db	-	pass+t	none	0	-	r	temp	0	0	-
db	func	func	func	1	pc_n	pc_n	pc_n	0	1	1

# abs_x with a zero carry
abs_x_zc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	c_sel
db	x	add	none	1	pc_n	pc_n	pc_n	1	t	-
db	-	pass+t	none	0	-	r	temp	0	0	-
db	func	func	func	1	pc_n	pc_n	pc_n	0	1	0

# abs_y looks like abs_x.
abs_y:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag
db	y	add	none	1	pc_n	pc_n	pc_n	1	t
db	-	pass+t	none	0	-	r	temp	0	0
db	func	func	func	1	pc_n	pc_n	pc_n	0	1

# abs_y with a one carry
abs_y_oc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	c_sel
db	y	add	none	1	pc_n	pc_n	pc_n	1	t	-
db	-	pass+t	none	0	-	r	temp	0	0	-
db	func	func	func	1	pc_n	pc_n	pc_n	0	1	1

# abs_y with a zero carry
abs_y_zc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	c_sel
db	y	add	none	1	pc_n	pc_n	pc_n	1	t	-
db	-	pass+t	none	0	-	r	temp	0	0	-
db	func	func	func	1	pc_n	pc_n	pc_n	0	1	0

zp_x:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag
db	x	add	none	0	-	0	r	0	0
db	func	func	func	1	pc_n	pc_n	pc_n	0	1

# zp_x with a one carry
zp_x_oc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	c_sel
db	x	add	none	0	-	0	r	0	0	-
db	func	func	func	1	pc_n	pc_n	pc_n	0	1	1

# zp_x with a zero carry
zp_x_zc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	c_sel
db	x	add	none	0	-	0	r	0	0	-
db	func	func	func	1	pc_n	pc_n	pc_n	0	1	0

# zp_y looks like zp_x.
zp_y:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag
db	y	add	none	0	-	0	r	0	0
db	func	func	func	1	pc_n	pc_n	pc_n	0	1

# zp_y with a zero carry
zp_y_zc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	c_sel
db	y	add	none	0	-	0	r	0	0	-
db	func	func	func	1	pc_n	pc_n	pc_n	0	1	0

inc:
a_sel	b_sel	alu_op	wrt_en	pcinc	pc_sel	a_h_sel	a_l_sel	tl_lat	flag
func	func	inc	func	0	-	pc_n	pc_n	0	1

dec:
a_sel	b_sel	alu_op	wrt_en	pcinc	pc_sel	a_h_sel	a_l_sel	tl_lat	flag
func	func	dec	func	0	-	pc_n	pc_n	0	1

# acc: (takes value in accumulator, sends it through ALU, and puts result in accumulator)
acc:
a_sel	b_sel	alu_op	wrt_en	pcinc	pc_sel	a_h_sel	a_l_sel	tl_lat	flag
-	a	func	func	0	pc_n	pc_n	pc_n	0	1

# acc with a zero carry
acc_zc:
a_sel	b_sel	alu_op	wrt_en	pcinc	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	c_sel
-	a	func	func	0	pc_n	pc_n	pc_n	0	1	0

mem_rw_zpa:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	memwri
db	-	pass	none	0	pc_n	0	r	1	0	0
db	func	func	func	0	-	0	temp	0	1	r
db	-	-	none	1	pc_n	pc_n	pc_n	0	0	0

# mem_rw_zpa with a zero carry
mem_rw_zpa_zc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	memwri	c_sel
db	-	pass	none	0	pc_n	0	r	1	0	0	-
db	func	func	func	0	-	0	temp	0	1	r	0
db	-	-	none	1	pc_n	pc_n	pc_n	0	0	0	-

# mem_rw_zpa with a one carry
mem_rw_zpa_oc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	memwri	c_sel
db	-	pass	none	0	pc_n	0	r	1	0	0	-
db	func	func	func	0	-	0	temp	0	1	r	1
db	-	-	none	1	pc_n	pc_n	pc_n	0	0	0	-

mem_rw_zpx:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	memwri
db	x	add	none	0	pc_n	0	r	1	0	0
db	func	func	func	0	-	0	temp	0	1	r
db	-	-	none	1	pc_n	pc_n	pc_n	0	0	0

# mem_rw_zpx with a zero carry
mem_rw_zpx_zc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	memwri	c_sel
db	x	add	none	0	pc_n	0	r	1	0	0	-
db	func	func	func	0	-	0	temp	0	1	r	0
db	-	-	none	1	pc_n	pc_n	pc_n	0	0	0	-

# mem_rw_zpx with a one carry
mem_rw_zpx_oc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	flag	memwri	c_sel
db	x	add	none	0	pc_n	0	r	1	0	0	-
db	func	func	func	0	-	0	temp	0	1	r	1
db	-	-	none	1	pc_n	pc_n	pc_n	0	0	0	-

mem_rw_abs:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	th_lat	flag	memwri
db	-	pass	none	1	pc_n	pc_n	pc_n	1	0	0	0
db	-	pass	none	0	pc_n	r	temp	0	1	0	0
db	func	func	func	0	-	temp	temp	0	0	1	r
db	-	-	none	1	pc_n	pc_n	pc_n	0	0	0	0

# mem_rw_abs with a zero carry
mem_rw_abs_zc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	th_lat	flag	memwri	c_sel
db	-	pass	none	1	pc_n	pc_n	pc_n	1	0	0	0	-
db	-	pass	none	0	pc_n	r	temp	0	1	0	0	-
db	func	func	func	0	-	temp	temp	0	0	1	r	0
db	-	-	none	1	pc_n	pc_n	pc_n	0	0	0	0	-

# mem_rw_abs with a one carry
mem_rw_abs_oc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	th_lat	flag	memwri	c_sel
db	-	pass	none	1	pc_n	pc_n	pc_n	1	0	0	0	-
db	-	pass	none	0	pc_n	r	temp	0	1	0	0	-
db	func	func	func	0	-	temp	temp	0	0	1	r	1
db	-	-	none	1	pc_n	pc_n	pc_n	0	0	0	0	-

mem_rw_abx:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	th_lat	flag	memwri
db	x	add	none	1	pc_n	pc_n	pc_n	1	0	t	0
db	-	pass+t	none	0	pc_n	r	temp	0	1	0	0
db	func	func	func	0	-	temp	temp	0	0	1	r
db	-	-	none	1	pc_n	pc_n	pc_n	0	0	0	0

# mem_rw_abx with a zero carry
mem_rw_abx_zc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	th_lat	flag	memwri	c_sel
db	x	add	none	1	pc_n	pc_n	pc_n	1	0	t	0	-
db	-	pass+t	none	0	pc_n	r	temp	0	1	0	0	-
db	func	func	func	0	-	temp	temp	0	0	1	r	0
db	-	-	none	1	pc_n	pc_n	pc_n	0	0	0	0	-

# mem_rw_abx with a one carry
mem_rw_abx_oc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	tl_lat	th_lat	flag	memwri	c_sel
db	x	add	none	1	pc_n	pc_n	pc_n	1	0	t	0	-
db	-	pass+t	none	0	pc_n	r	temp	0	1	0	0	-
db	func	func	func	0	-	temp	temp	0	0	1	r	1
db	-	-	none	1	pc_n	pc_n	pc_n	0	0	0	0	-

indirect_y:
# over by two cycles
# "indirect indexed" addressing: *((*arg)+y)
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	th_lat	tl_lat	flag
# Address of low byte comes in over data line -- save it in temp_high and pass it to address
db	-	pass	none	0	-	0	r	1	0	0
# Low byte comes in on data -- pass it and store in temp_low
db	-	pass	none	0	-	-	-	0	1	0
# Increment address of low byte to get address of high byte -- pass to address 
th	-	inc	none	0	-	0	r	0	0	0
# Data from high byte comes in -- save in temp_high
db	-	pass	none	0	-	-	-	1	0	0
# Add y to low byte and save back in low byte
tl	y	add	none	0	-	-	-	0	1	t
# Add carry to high byte and save back in high byte
th	-	pass+t	none	0	-	-	-	1	0	0
# Get data from address stored in temps
db	-	pass	none	0	-	temp	temp	0	0	0
# Data comes in on data line.  Opcode PLA decides what to do for the rest. PC is incremented
db	func	func	func	1	pc_n	pc_n	pc_n	0	0	1

# indirect_y with a one carry
indirect_y_oc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	th_lat	tl_lat	flag	c_sel
db	-	pass	none	0	-	0	r	1	0	0	-
db	-	pass	none	0	-	-	-	0	1	0	-
th	-	inc	none	0	-	0	r	0	0	0	-
db	-	pass	none	0	-	-	-	1	0	0	-
tl	y	add	none	0	-	-	-	0	1	t	-
th	-	pass+t	none	0	-	-	-	1	0	0	-
db	-	pass	none	0	-	temp	temp	0	0	0	-
db	func	func	func	1	pc_n	pc_n	pc_n	0	0	1	1

# indirect_y with a zero carry
indirect_y_zc:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	th_lat	tl_lat	flag	c_sel
db	-	pass	none	0	-	0	r	1	0	0	-
db	-	pass	none	0	-	-	-	0	1	0	-
th	-	inc	none	0	-	0	r	0	0	0	-
db	-	pass	none	0	-	-	-	1	0	0	-
tl	y	add	none	0	-	-	-	0	1	t	-
th	-	pass+t	none	0	-	-	-	1	0	0	-
db	-	pass	none	0	-	temp	temp	0	0	0	-
db	func	func	func	1	pc_n	pc_n	pc_n	0	0	1	0

# store and read-modify-write instructions look a lot like these.
# RMW ops must use non-default data read source R.

push:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	memwri
sp	func	dec	sp	0	-	1	r	1
-	-	-	none	pc_n	pc_n	pc_n	pc_n	0

pull:                                                                           
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	memwri
sp	-	pass	none	0	-	1	r	0
db	-	pass	func	0	-	-	-	0
sp	-	inc	sp	1	pc_n	pc_n	pc_n	0

jsr:
# push high order byte of pc+2, then low order byte, jump to {pcl, pch}.
# one cycle long.
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	th_lat	tl_lat	memwri	pcinc
db	-	pass	none	1	pc_n	pc_n	pc_n	0	1	0	1
db	-	pass	none	0	-	-	-	1	0	0	1
sp	pc_h	dec	sp	0	-	1	r	0	0	b	0
sp	pc_l	dec	sp	0	-	1	r	0	0	b	0
tl	-	pass	pc_l	01	r	-	-	0	0	0	0
th	-	pass	pc_h	10	r	temp	temp	0	0	0	0

#rts:
#a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	th_lat	tl_lat	memwri	pcinc
#sp	-	inc	none	0	-	-	-	1	0	0	0
#sp	-	inc	none	0	-	-	-	0	1	0	0
#db	-	pass	none	1	r	temp	temp	0	0	0	1

jmp_abs:
# absolute jump
# can't munge PC until we fetch the high part, so we write the low part back
# on the third cycle
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	th_lat	tl_lat
db	-	pass	none	1	pc_n	pc_n	pc_n	0	1
db	-	pass	pc_h	10	r	r	temp	1	0
tl	-	pass	pc_l	01	r	temp	temp	0	0

jmp_ind:
# recall bug with page crossing
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	th_lat	tl_lat	pcinc
db	-	pass	none	1	pc_n	pc_n	pc_n	0	1	1
db	-	pass	none	0	-	r	temp	1	0	0
db	-	pass	pc_l	01	r	-	-	0	0	0
tl	-	inc	none	0	-	temp	r	0	0	0
# this is where we'd fix Mr. Peddle's bug.
db	-	pass	pc_h	10	r	r	pc_n	0	0	0

rts:
# pull low, then high of pc, jump to pc+1
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	pcinc
sp	-	pass	none	0	-	1	r	0
db	-	pass	pc_l	01	r	-	-	0
sp	-	inc	sp	0	-	1	r	0
db	-	pass	pc_h	10	r	-	-	0
sp	-	inc	sp	1	pc_n	pc_n	pc_n	1

rti:
# pull p, then pc, jump to pc. similar to above, but don't increment PC
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	pcinc	flag
sp	-	pass	none	0	-	1	r	0	0
db	-	pass	p	0	-	-	-	0	1
sp	-	dec	sp	0	-	1	r	0	0
db	-	pass	pc_l	01	r	-	-	0	0
sp	-	dec	sp	0	-	1	r	0	0
db	-	pass	pc_h	10	r	-	-	0	0
sp	-	dec	sp	1	pc_n	pc_n	pc_n	0	0

branch_head:
a_sel	b_sel	alu_op	wrt_en	pc_w_en	pc_sel	a_h_sel	a_l_sel	pcinc	flag	tl_lat	th_lat	nxt_src
db	pc_l	add+1	none	1	pc_n	pc_n	pc_n	1	t	1	0	b

# if we don't take the branch, go back to base.

